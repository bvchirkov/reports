#Краткая история Git

Как и многие замечательные вещи, Git начинался с, в некотором роде, 
разрушения во имя созидания и жарких споров. Ядро Linux — действительно 
очень большой открытый проект. Большую часть существования ядра Linux 
(1991-2002) изменения к нему распространялись в виде патчей и 
заархивированных файлов. В 2002 году проект перешёл на проприетарную 
РСКВ BitKeeper.

В 2005 году отношения между сообществом разработчиков ядра Linux и 
компанией, разрабатывавшей BitKeeper, испортились, и право бесплатного 
пользования продуктом было отменено. Это подтолкнуло разработчиков Linux 
(и в частности Линуса Торвальдса, создателя Linux) разработать 
собственную систему, основываясь на опыте, полученном за время 
использования BitKeeper. Основные требования к новой системе были 
следующими:

-	Скорость
-	Простота дизайна
-	Поддержка нелинейной разработки (тысячи параллельных веток)
-	Полная распределённость
-	Возможность эффективной работы с такими большими проектами, как 
ядро Linux (как по скорости, так и по размеру данных)

С момента рождения в 2005 году Git развивался и эволюционировал, 
становясь проще и удобнее в использовании, сохраняя при этом свои 
первоначальные качества. Он невероятно быстр, очень эффективен для 
больших проектов, а также обладает превосходной системой ветвления для 
нелинейной разработки.


#Основы Git

##Слепки вместо патчей

Главное отличие Git'а от любых других СКВ (например, Subversion и ей 
подобных) — это то, как Git смотрит на свои данные. В принципе, 
большинство других систем хранит информацию как список изменений 
(патчей) для файлов. Эти системы (CVS, Subversion, Perforce, Bazaar и 
другие) относятся к хранимым данным как к набору файлов и изменений, 
сделанных для каждого из этих файлов во времени.

![GitReport1.png](/img/GitReport/GitReport1.png "GitReport1.png")


Git не хранит свои данные в таком виде. Вместо этого Git считает 
хранимые данные набором слепков небольшой файловой системы. Каждый раз, 
когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет 
слепок того, как выглядят все файлы проекта на текущий момент. Ради 
эффективности, если файл не менялся, Git не сохраняет файл снова, а 
делает ссылку на ранее сохранённый файл.

![GitReport2.png](/img/GitReport/GitReport2.png "GitReport2.png")


Это важное отличие Git'а от практически всех других систем контроля 
версий. Из-за него Git вынужден пересмотреть практически все аспекты 
контроля версий, которые другие системы переняли от своих 
предшественниц. Git больше похож на небольшую файловую систему с 
невероятно мощными инструментами, работающими поверх неё, чем на просто 
СКВ.

##Почти все операции — локальные

Для совершения большинства операций в Git'е необходимы только локальные 
файлы и ресурсы, т.е. обычно информация с других компьютеров в сети не 
нужна. Если вы пользовались централизованными системами, где практически 
на каждую операцию накладывается сетевая задержка, вы, возможно, 
подумаете, что боги наделили Git неземной силой. Поскольку вся история 
проекта хранится локально у вас на диске, большинство операций кажутся 
практически мгновенными.

К примеру, чтобы показать историю проекта, Git'у не нужно скачивать её с 
сервера, он просто читает её прямо из вашего локального репозитория. 
Поэтому историю вы увидите практически мгновенно. Если вам нужно 
просмотреть изменения между текущей версией файла и версией, сделанной 
месяц назад, Git может взять файл месячной давности и вычислить разницу 
на месте, вместо того чтобы запрашивать разницу у СКВ-сервера или качать 
с него старую версию файла и делать локальное сравнение.

Кроме того, работа локально означает, что мало чего нельзя сделать без 
доступа к Сети или VPN. Если вы в самолёте или в поезде и хотите немного 
поработать, можно спокойно делать коммиты, а затем отправить их, как 
только станет доступна сеть.

##Git следит за целостностью данных

Перед сохранением любого файла Git вычисляет контрольную сумму, и она 
становится индексом этого файла. Поэтому невозможно изменить содержимое 
файла или каталога так, чтобы Git не узнал об этом. Эта функциональность 
встроена в сам фундамент Git'а и является важной составляющей его 
философии. Если информация потеряется при передаче или повредится на 
диске, Git всегда это выявит.

Работая с Git'ом, вы будете встречать эти хеши повсюду, поскольку он их 
очень широко использует. Фактически, в своей базе данных Git сохраняет 
всё не по именам файлов, а по хешам их содержимого.

##Чаще всего данные в Git только добавляются

Практически все действия, которые вы совершаете в Git'е, только 
добавляют данные в базу. Очень сложно заставить систему удалить данные 
или сделать что-то неотменяемое. Можно, как и в любой другой СКВ, 
потерять данные, которые вы ещё не сохранили, но как только они 
зафиксированы, их очень сложно потерять, особенно если вы регулярно 
отправляете изменения в другой репозиторий.

##Три состояния

В Git'е файлы могут находиться в одном из трёх состояний: 
зафиксированном, изменённом и подготовленном. "Зафиксированный" значит, 
что файл уже сохранён в вашей локальной базе. К изменённым относятся 
файлы, которые поменялись, но ещё не были зафиксированы. Подготовленные 
файлы — это изменённые файлы, отмеченные для включения в следующий 
коммит.

Таким образом, в проектах, использующих Git, есть три части: каталог 
Git'а (Git directory), рабочий каталог (working directory) и область 
подготовленных файлов (staging area).

![GitReport3.png](/img/GitReport/GitReport3.png "GitReport3.png")


Каталог Git'а — это место, где Git хранит метаданные и базу данных 
объектов вашего проекта. Это наиболее важная часть Git'а, и именно она 
копируется, когда вы клонируете репозиторий с другого компьютера.
Рабочий каталог — это извлечённая из базы копия определённой версии 
проекта. Эти файлы достаются из сжатой базы данных в каталоге Git'а и 
помещаются на диск для того, чтобы вы их просматривали и редактировали.
Область подготовленных файлов — это обычный файл, обычно хранящийся в 
каталоге Git'а, который содержит информацию о том, что должно войти в 
следующий коммит. Иногда его называют индексом (index), но в последнее 
время становится стандартом называть его областью подготовленных файлов 
(staging area).

Стандартный рабочий процесс с использованием Git'а выглядит примерно 
так:

1.Вы вносите изменения в файлы в своём рабочем каталоге.
2.Подготавливаете файлы, добавляя их слепки в область 
подготовленных файлов.
3.Делаете коммит, который берёт подготовленные файлы из индекса и 
помещает их в каталог Git'а на постоянное хранение.
Если рабочая версия файла совпадает с версией в каталоге Git'а, файл 
считается зафиксированным. Если файл изменён, но добавлен в область 
подготовленных данных, он подготовлен. Если же файл изменился после 
выгрузки из БД, но не был подготовлен, то он считается изменённым. 


